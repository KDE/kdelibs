/* ANSI-C code produced by gperf version 2.7 */
/* Command-line: gperf -a -L ANSI-C -C -E -c -o -t -k * -NfindTag -D -s 2 khtmltags.gperf  */
/* This file is automatically generated from khtmltags.in by maketags, do not edit */
/* Copyright 1998 W. Bastian */
#include "khtmltags.h"
struct tags {
    const char *name;
    int id;
};
/* maximum key range = 353, duplicates = 1 */

#ifdef __GNUC__
__inline
#endif
static unsigned int
hash (register const char *str, register unsigned int len)
{
  static const unsigned short asso_values[] =
    {
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354,  50,
       35,  40,  45,  10,  15, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354,   0,  95, 115,
       35,   0,  70,  20,  15,  30,   0,  20,  10,  85,
        5,   0, 110,  10,   5,   5,   0,  85,   0, 354,
        5,   0, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354
    };
  register int hval = len;

  switch (hval)
    {
      default:
      case 10:
        hval += asso_values[(unsigned char)str[9]];
      case 9:
        hval += asso_values[(unsigned char)str[8]];
      case 8:
        hval += asso_values[(unsigned char)str[7]];
      case 7:
        hval += asso_values[(unsigned char)str[6]];
      case 6:
        hval += asso_values[(unsigned char)str[5]];
      case 5:
        hval += asso_values[(unsigned char)str[4]];
      case 4:
        hval += asso_values[(unsigned char)str[3]];
      case 3:
        hval += asso_values[(unsigned char)str[2]];
      case 2:
        hval += asso_values[(unsigned char)str[1]];
      case 1:
        hval += asso_values[(unsigned char)str[0]];
        break;
    }
  return hval;
}

#ifdef __GNUC__
__inline
#endif
const struct tags *
findTag (register const char *str, register unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 95,
      MIN_WORD_LENGTH = 1,
      MAX_WORD_LENGTH = 10,
      MIN_HASH_VALUE = 1,
      MAX_HASH_VALUE = 353
    };

  static const struct tags wordlist[] =
    {
      {"a", ID_A},
      {"tt", ID_TT},
      {"s", ID_S},
      {"tr", ID_TR},
      {"var", ID_VAR},
      {"area", ID_AREA},
      {"q", ID_Q},
      {"ol", ID_OL},
      {"th", ID_TH},
      {"textarea", ID_TEXTAREA},
      {"style", ID_STYLE},
      {"hr", ID_HR},
      {"h5", ID_H5},
      {"i", ID_I},
      {"h6", ID_H6},
      {"dt", ID_DT},
      {"td", ID_TD},
      {"strong", ID_STRONG},
      {"li", ID_LI},
      {"ins", ID_INS},
      {"title", ID_TITLE},
      {"dl", ID_DL},
      {"del", ID_DEL},
      {"h2", ID_H2},
      {"head", ID_HEAD},
      {"thead", ID_THEAD},
      {"h3", ID_H3},
      {"h4", ID_H4},
      {"strike", ID_STRIKE},
      {"h1", ID_H1},
      {"div", ID_DIV},
      {"link", ID_LINK},
      {"dd", ID_DD},
      {"dir", ID_DIR},
      {"tfoot", ID_TFOOT},
      {"legend", ID_LEGEND},
      {"font", ID_FONT},
      {"u", ID_U},
      {"em", ID_EM},
      {"meta", ID_META},
      {"address", ID_ADDRESS},
      {"b", ID_B},
      {"ul", ID_UL},
      {"br", ID_BR},
      {"base", ID_BASE},
      {"listing", ID_LISTING},
      {"nobr", ID_NOBR},
      {"table", ID_TABLE},
      {"p", ID_P},
      {"dfn", ID_DFN},
      {"html", ID_HTML},
      {"small", ID_SMALL},
      {"isindex", ID_ISINDEX},
      {"pre", ID_PRE},
      {"label", ID_LABEL},
      {"span", ID_SPAN},
      {"col", ID_COL},
      {"center", ID_CENTER},
      {"bdo", ID_BDO},
      {"body", ID_BODY},
      {"tbody", ID_TBODY},
      {"select", ID_SELECT},
      {"img", ID_IMG},
      {"big", ID_BIG},
      {"cite", ID_CITE},
      {"option", ID_OPTION},
      {"kbd", ID_KBD},
      {"code", ID_CODE},
      {"fieldset", ID_FIELDSET},
      {"plain", ID_PLAIN},
      {"form", ID_FORM},
      {"frame", ID_FRAME},
      {"frameset", ID_FRAMESET},
      {"noframes", ID_NOFRAMES},
      {"menu", ID_MENU},
      {"basefont", ID_BASEFONT},
      {"sub", ID_SUB},
      {"button", ID_BUTTON},
      {"iframe", ID_IFRAME},
      {"map", ID_MAP},
      {"abbr", ID_ABBR},
      {"sup", ID_SUP},
      {"samp", ID_SAMP},
      {"param", ID_PARAM},
      {"object", ID_OBJECT},
      {"acronym", ID_ACRONYM},
      {"embed", ID_EMBED},
      {"input", ID_INPUT},
      {"applet", ID_APPLET},
      {"caption", ID_CAPTION},
      {"script", ID_SCRIPT},
      {"noscript", ID_NOSCRIPT},
      {"optgroup", ID_OPTGROUP},
      {"blockquote", ID_BLOCKQUOTE},
      {"colgroup", ID_COLGROUP}
    };

  static const short lookup[] =
    {
        -1,    0,    1,   -1,   -1,   -1,    2,    3,
         4,    5,   -1,    6,    7,   -1,   -1,   -1,
        -1,    8,    9,   -1,   10,   -1,   11,   -1,
        -1,   -1,   -1,   12,   -1,   -1,   -1,   13,
        14,   -1,   -1,   -1,   -1, -134,  -80,   -2,
        -1,   17,   18,   19,   -1,   20,   -1,   21,
        22,   -1,   -1,   -1,   23,   -1,   24,   25,
        -1,   26,   -1,   -1,   -1,   -1,   27,   -1,
        -1,   -1,   28,   29,   30,   31,   -1,   -1,
        32,   33,   -1,   34,   35,   -1,   -1,   36,
        -1,   -1,   -1,   -1,   -1,   -1,   37,   38,
        -1,   39,   -1,   -1,   40,   -1,   -1,   -1,
        41,   42,   -1,   -1,   -1,   -1,   43,   -1,
        44,   -1,   -1,   45,   -1,   46,   47,   48,
        -1,   49,   50,   51,   -1,   52,   53,   -1,
        54,   -1,   -1,   -1,   55,   -1,   -1,   -1,
        56,   -1,   -1,   57,   -1,   58,   59,   60,
        61,   -1,   62,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   63,   64,   -1,   65,
        -1,   66,   67,   -1,   -1,   -1,   68,   -1,
        69,   -1,   -1,   -1,   70,   71,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   72,   -1,   -1,
        -1,   -1,   73,   74,   -1,   -1,   -1,   75,
        -1,   -1,   -1,   -1,   76,   -1,   -1,   77,
        -1,   -1,   -1,   -1,   78,   -1,   79,   80,
        -1,   -1,   -1,   81,   82,   83,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        84,   85,   -1,   -1,   86,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   87,   88,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   89,   -1,   -1,   -1,   90,
        -1,   -1,   -1,   -1,   -1,   -1,   91,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   92,   -1,   -1,   -1,   -1,   -1,
        -1,   93,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   94
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      register int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= 0)
        {
          register int index = lookup[key];

          if (index >= 0)
            {
              register const char *s = wordlist[index].name;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[index];
            }
          else if (index < -TOTAL_KEYWORDS)
            {
              register int offset = - 1 - TOTAL_KEYWORDS - index;
              register const struct tags *wordptr = &wordlist[TOTAL_KEYWORDS + lookup[offset]];
              register const struct tags *wordendptr = wordptr + -lookup[offset + 1];

              while (wordptr < wordendptr)
                {
                  register const char *s = wordptr->name;

                  if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                    return wordptr;
                  wordptr++;
                }
            }
        }
    }
  return 0;
}
