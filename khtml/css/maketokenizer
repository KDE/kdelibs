#!/usr/bin/perl

open(IN, "flex -t tokenizer.flex|") or die "no flex?\n";
open(OUT, ">tokenizer.cpp") or die $!;

print OUT <<STOP;
/*
 * This file is part of the DOM implementation for KDE.
 *
 * Copyright 2003 Lars Knoll (knoll\@kde.org)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

/* This file is mostly data generated by flex. Unfortunately flex
   can't handle 16bit strings directly, so we just copy the part of
   the code we need and modify it to our needs.

   Most of the defines below are to make sure we can easily use the
   flex generated code, using as little editing as possible.

   The flex syntax to generate the lexer are more or less directly
   copied from the CSS2.1 specs, with some fixes for comments and
   the important symbol.

   To regenerate, run flex on tokenizer.flex. After this, copy the
   data tables and the YY_DECL method over to this file. Remove the
   init code from YY_DECL and change the YY_END_OF_BUFFER to only call
   yyterminate().

*/

// --------- begin generated code -------------------

STOP
print OUT<<STOP;

#include "parser.h"

#define INITIAL 0
#define mediaquery 1
#define at_rule 2
#define block 3

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;
#endif /* ! C99 */
STOP

while (<IN>) {
    /YY_NUM_RULES/../yy_last_accepting/ 
               and !/yy_last_accepting/ and print OUT;
    /^YY_DECL/ and print OUT and last;
}

while (<IN>) {
    s/char/unsigned short/;
    print OUT;
    last if /yy_act/;
}

while (<IN>) {
    last if /while \( 1 \)/;
}

print OUT;
while (<IN>) {
    next if /^yy_match:/;
    next if /^do_action:/;
    last if /YY_END_OF_BUFFER/;
    print OUT;
    print OUT "case YY_END_OF_BUFFER:\n" if /^case YY_STATE_EOF\(INITIAL\):/;
}

while (<IN>) {
    last if /default:/;
}

print OUT;
while (<IN>) {
    print OUT;
    last if /end of yylex/;
}
